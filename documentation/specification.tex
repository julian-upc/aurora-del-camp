\documentclass[11pt,reqno]{amsart}

\usepackage{times}
\usepackage{microtype}
\usepackage{amssymb}
\usepackage{paralist}
\usepackage{url}
\usepackage{a4wide}
\usepackage{bbm}

\newcommand{\NN}{\mathbbm{N}}
\newcommand{\ZZ}{\mathbbm{Z}}

\newcommand{\lra}{\longrightarrow}

\numberwithin{equation}{section}
\newcommand{\ojo}[1]{\textsf{\bfseries\boldmath{#1}}}

\begin{document}

\renewcommand*\descriptionlabel[1]{%
\hspace\labelsep\normalfont\itshape #1:}

\newenvironment{mydesc}{%
  \begin{description}\setlength{\itemsep}{1ex}}%
  {\end{description}}

\title{Aurora del Camp -- specification}
\author{Julian Pfeifle}
\date{Version of \today}
\maketitle

This document outlines some of the issues that arise in the
implementation of Gilad's proposal~\cite{buzi11}.

\medskip
Given the availability of powerful free and open source solvers for
integer programs such as CBC~\cite{cbc}, it seems natural to pursue an
integer programming formulation. Of course, free solvers are not as
good as the best commercial ones, but the most recent
benchmarks~\cite{mittelmann11} indicate that CBC is reasonably
competitive; more precisely, it's the most competitive among all
solvers that have an open source license (in the case of CBC, the
``Eclipse Public License'') that permits Gilad to use it commercially
without paying any license fees.

\section{Event-based modeling}


\subsection{Activities to be considered}

In the parlance of \cite{artigues-etal11}, we want to schedule a set
of \emph{activities} subject to certain constraints. In our setup,
each activity is associated to a certain specific part of the
available fields. We refer to these parts or areas as \emph{lots}, and
collect them into a set~$L$. We allow them to have different
sizes.

The activities to be carried out in or on these lots come in two types: $A=A_c\cup A_s$,
where the activities in $A_c$ only affect the field and are thus \emph{``common''} to all
crops, and the activities~$A_s$ are \emph{``specific''} to each crop. Moreover, we allow
each activity to occur multiple times in different time windows, to take into account
repeated sowing, harvesting, etc. We keep track of the repetitions by remembering, for
each activity, a \emph{valid start time window} $\omega_{\rm start} = [w_1, w_2]$ of weeks
in which it may begin. This has the added advantage that certain characteristics of the
activity, such as the duration or the yield, may depend on the start time. For example,
\emph{``planting tomatoes in week 34 or 35''} and \emph{``planting tomatoes in week 48 or
  49''} will be separate activities, each with distinct durations and yield. The
optimization process will determine whether to carry out none, one or both of these
activities. As an abstract notation, we write~$W$ for the set of all useful start time
windows $\omega = \omega_{\rm start}$, i.e., all intervals contained in the planning
horizon of the problem that are eligible for starting a task.

\smallskip
Gilad breaks the two types of activities down as follows:

\begin{mydesc}
\item[Activities common to all crops] $ti$~for tilling, $rv$~for rotovating, $gm$~for
  green manure planting, $f\!t$~for fertilizing, $bb$~for bed building, $si$~for setting
  up irrigation, $sr$ for setting rows, $we$ for weeding. Since each of these activities
  can occur on each lot, and be repeated, we set
  \[
     A_c 
     \ = \
     \{ ti,\;rv,\;gm,\;f\!t,\;bb,\;si,\;sr,\;we\} \times L \times W.
  \]
  A typical activity in $A_c$ is therefore $(ti,\ell, \omega)$ for some $\ell\in L$ and
  $\omega\in W$, which we write as $ti_{\ell, \omega}$ and take to mean ``tilling the lot
  $\ell$ starting in the time window~$\omega$''.


\item[Activities specific to a crop] $by$ for buying seeds, $ss$ for soaking seeds, $cs$
  for cutting or separating cloned seeds, $gc$~for false germination and cleaning,
  $pl$~for planting\footnote{We consider transplanting and planting to be the same
    process.}, $gr$ for growing, $f\!u$ for fumigating, $th$ for thinning, $tr$ for
  trimming, $co$ for covering, $ha$~for harvesting. We assemble these into
  \[
     A_s = \{ by,\;ss,\;cs,\;gc,\;pl,\;f\!u,\;th,\;tr,\;co,\;ha\}
     \times C \times L \times W,
  \]
  where $C$ is the set of crops. A typical activity in~$A_s$ is therefore $(ha,c,\ell,
  \omega)=ha_{c,\ell, \omega}$, which means ``harvesting the crop $c\in C$ in the lot
  $\ell\in L$, starting during the time window~$\omega$''.
\end{mydesc}

The estimates $|L|=30$, $|R|=5$, $|C|=40$ yield an upper bound of
\[
    8 \times 30 \times 5 + 10 \times 40 \times 30 \times 5
    \ = \
    61\,200
\]
activities in the model, which is a very manageable figure for commercial solvers, and
should also not present unsurmountable problems to free solvers such as CBC.

\subsection{Precedence constraints}

We record the precedence constraints between  activities in a directed acyclic
graph~$H$. Thus, $t_1\lra t_2$ (also written $t_1<t_2$) is a directed edge
in~$H$ if $t_1$~must be completed before $t_2$~can start. 

\subsection{Chains}
We further group activities into \emph{chains}, or activities that must go
together. For example,
\[
   \chi
   \ = \
   \big(pl_{c,\ell,[w_0,w_1]}, \;
    we_{\ell,[w_2,w_3]},\;
    we_{\ell,[w_3,w_4]},\;
    gr_{\ell,[w_1,w_4]},\;
    ha_{c,\ell,[w_4,w_5]}\big)
\]
with $w_0<w_1<w_2<w_3<w_4<w_5$ is a chain consisting of \emph{planting}, \emph{weeding}
(twice), and \emph{harvesting} a crop $c$ in a lot~$\ell$ that needs $w_4-w_1$~weeks to
\emph{grow}. The directed graph~$H$ records that in this particular chain, \emph{growing}
and \emph{weeding} may be carried out in parallel, but both these activities come after
\emph{planting} and before \emph{harvesting}. In general, the set of all chains is denoted
by~$K$, and if the first activity in a chain~$\chi$ is executed, all the others must be
executed too. 

\subsection{Overview of the model}


We separate the \emph{scheduling} part of the problem, in which the
appropriate sequencing of events is determined, from the
\emph{allocation} part, in which activities and crops are assigned
their proper place in the field. First, the optimal sequencing of
events is determined in a way that respects the available field space
and work force using an \emph{event-based} formulation (see below);
allocation is relegated to a second step. Separating the two phases
makes it easier to formulate each one, and presumably makes them (and
thus, the whole problem) easier to solve.

In general terms, we will plan over several years. In the final
program, there will be an interface to put new activities into a
\emph{task queue} (a set of events that is not scheduled yet), and an
interface to record the actual progress of activities. This act of
recording the real start and end time of activities, environmental
changes, changes in the available work force, etc., sets certain
variables in the problem formulation to fixed, known values, and
allows Gilad to frequently update the solution of the optimization
problem and dynamically take into account the latest developments.

\section{Scheduling}

Before we start with the model, we remark that the setup in \cite{artigues-etal11} allows
for incorporating constraints on resources. The main \emph{non-renewable} resource that
comes to mind is ``time'', while some  \emph{renewable} ones are ``space in the
fields'', ``money'' and ``gasoline''. Money is put back into the system by selling 
crops, and field space by tilling the remains of the crop. Gasoline is renewable, but
costs money.

Of these resources, the only one we need to model explicitly at this point is field
space. The resource ``time'' is handled by the processing times introduced below. I do not
have sufficient understanding at the moment to know whether use of gasoline can be
optimized or not. Money will be handled by the objective function.

\subsection{Variables}

We now proceed to model our problem.  To the activities in $A$ we associate a set~$E$ of
\emph{events}, which consist of the acts of starting and finishing each activity in~$A$;
thus, $|E|=2|A|=:n$. In consequence, we may consider $E=\{1,2,\dots, 2|A|=n\}$ to be
totally ordered.  Following \cite{artigues-etal11}, we introduce the following variables
and data:

\begin{enumerate}
\item A set of binary decision variables 
  \[
     Z
     \ = \
     \big\{z_{a,e}: a\in A, e\in E\big\},
  \]
  where each $z_{a,e}=1$ if and only if activity~$a$ starts at
  event~$e$ or is still in execution at event~$e$.

\smallskip
\item A set of continuous variables that indicate the starting time of each event:
  \[
     T
     \ = \
     \big\{t_e : e\in E\big\}
  \]

\smallskip
\item The set of \emph{processing times} for each activity:
  \[
      \{p_a:a\in A\}
  \]  
  These must be estimated from experience, and are necessarily averages. There are two
  issues here:
  \begin{description}
  \item[Variations in the number of hands available on the farm] One way to take these
    into account could be the following: The processing times stored in the database are
    the times it would take one worker to complete each task. In the user interface, there
    will be a field to enter the current number of available helpers. Each time the
    current optimization problem is generated, the processing times in the database are
    divided by the number of available workers before being written to the optimization
    file. More sophisticated setups are possible, but will be relegated to a future stage
    of development.

  \item[Seasonal variations] The processing time of some activities varies with the moment
    of the year in which they are executed. For example, Gilad states that growing lettuce
    in August just takes one month, but three months if they are planted in October.
  \end{description}
  \smallskip
\item The total field space available, $S$, and the space taken up
  by each activity,
  \[
      \{s_a : a\in A\}
  \]

\smallskip
\item The yield $y_{c,w}$ of each crop $c\in C$, depending on the week $w\in W$ in which
  it is planted.

\end{enumerate}

\subsection{Constraints internal to the model}

We now adapt the individual constraints from~\cite{artigues-etal11}:

\begin{mydesc}

\item[Not all activities have to execute] We do \emph{not} incorporate a constraint
  $\sum_{e\in E} z_{a,e}=1$ for all $a\in A$, because we do not wish to require all
  activities to execute. This leaves Gilad margin to queue activities such as ``sowing and
  harvesting beans for the fifth time'' that may or may not take place, but where the
  decision on them having take place or not is an outcome of the optimization process and
  not an a-priori input to the problem formulation.

  Initially, it therefore seems to be a good idea to queue more repetitions of activities
  than could reasonably be undertaken, so that the optimal number of repetitions may be
  learned from the optimization process. We'll see how this works out.

\item[Activities in a chain must go together] \ojo{implement me}

\item[Setting the starting time] Instead of using $t_0=0$, we set
  \begin{equation}
     t_0
     \ = \
     w_0,
  \end{equation}
  where $w_0$ indexes the week of the year where optimization starts. In general, using
  weeks as units for time seems to be a good idea.

\item[Ordering the execution starts]
  \begin{equation}
     t_{e+1} 
     \ \ge \
     t_e
     \qquad\text{for all }
      e\in E\smallsetminus\{n\}
  \end{equation}

\item[Execution start constraints] Relations that implement start time windows:
  \begin{equation}
    w_{1,e}\ \le\ t_e \ \le \ w_{2,e}
    \qquad\text{for all } e\in E
  \end{equation}
  

\item[Duration constraints]
  \begin{equation}
     t_f 
     \ \ge \
     t_e + \big((z_{a,e} - z_{a,e-1} ) - (z_{a,f} - z_{a,f-1}) - 1\big) p_a
     \qquad\text{for all } f>e\in E,\; a\in A
  \end{equation}
  As discussed in \cite{artigues-etal11}, these constraints ensure that,
if activity $a$ starts at event $e$ and ends at~$f$, then the time difference between  $f$
and $e$ is at least the processing time of $a$: $t_f \ge t_e + p_a$.

\item[Contiguity constraints] As proved in \cite[Proposition 1]{artigues-etal11a}, the
  constraints
  \begin{eqnarray}
    \sum_{i=1}^{e-1} z_{a,i}
    &\le&
    \phantom{(n-e)}\llap{$e$}\,\big(1-(z_{a,e} - z_{a,e-1})\big)
    \qquad\text{for all } e\in E\smallsetminus\{1\},\; a\in A
    \\
    \sum_{i=e}^n z_{a,i}
    &\le&
    (n-e)\,\big(1+(z_{a,e} - z_{a,e-1})\big)
    \qquad\text{for all } e\in E\smallsetminus\{1\},\; a\in A
  \end{eqnarray}
  ensure \emph{non-preemption}, i.e., the events after which the activity $a$ is being
  processed are adjacent.

\item[Precedence constraints] The implication $(z_{a,e}=1) \Longrightarrow
  \big(\sum_{i=1}^{e} z_{b,i}=0\big)$ that describes the directed edge $a\lra b\in H$ for
  each event~$e$ is modeled by the linear inequality
  \begin{equation}
     z_{a,e} + \sum_{i=1}^e z_{b,i}
     \ \le \
     1+(1-z_{a,e})e
     \qquad\text{for all } e\in E,\; a\lra b\in H
  \end{equation}

\item[Space constraints] At any given time, all current activities must take up no more
  than the entire available space:
  \begin{equation}
    \sum_{e=1}^n s_a \, z_{a,e} 
    \ \le \
    S \qquad\text{for all } a\in A
  \end{equation}
\end{mydesc}

\subsection{External constraints}

We may also incorporate constraints that come from the way crops behave. For example,
Gilad gives the example that \emph{``A head of lettuce planted in summer must be harvested
  the week after it is planted, but if it is planted in winter, it can stay in the ground
  for up to two months.''} This can be modeled via a set of chains 
\begin{eqnarray*}
   \chi_{25} 
   &=& 
   \big(
      pl_{\text{lettuce},\, \text{\#42},\, 25}, \; 
      we_{\text{lettuce},\, \text{\#42},\, [25,26]}, \;
      gr_{\text{lettuce},\, \text{\#42},\, [25,26]}, \;
      ha_{\text{lettuce},\, \text{\#42},\, [25,26]}
      \big), \\
   \chi_{26} 
   &=& 
   \big(
      pl_{\text{lettuce},\, \text{\#42},\, 26}, \; 
      we_{\text{lettuce},\, \text{\#42},\, [26,27]}, \;
      gr_{\text{lettuce},\, \text{\#42},\, [26,27]}, \;
      ha_{\text{lettuce},\, \text{\#42},\, [26,27]}
      \big), \\
   &\dots& \\
   \chi_{35} 
   &=& 
   \big(
      pl_{\text{lettuce},\, \text{\#42},\, 35}, \; 
      we_{\text{lettuce},\, \text{\#42},\, [35,36]}, \;
      gr_{\text{lettuce},\, \text{\#42},\, [35,36]}, \;
      ha_{\text{lettuce},\, \text{\#42},\, [35,36]}
      \big)
\end{eqnarray*}
that say that lettuces \emph{planted} from the middle of June (week 25) to the last week
of August (week 35) in a certain lot (\#42 in this example) must be \emph{weeded} exactly
once, need one week to \emph{grow}, and must be \emph{harvested} one week after planting;
and a set of chains
\begin{eqnarray*}
    \chi_{47} 
   &=& 
   \big(
      pl_{\text{lettuce},\, \text{\#42},\, 47}, \; 
      we_{\text{lettuce},\, \text{\#42},\, [47,49]}, \;
      we_{\text{lettuce},\, \text{\#42},\, [50,52]}, \;
      we_{\text{lettuce},\, \text{\#42},\, [53,55]}, 
   \\ && \hspace{5.4cm}
      gr_{\text{lettuce},\, \text{\#42},\, [47,55]}, \;
      ha_{\text{lettuce},\, \text{\#42},\, [47,55]} \;
      \big), \\
    \chi_{48} 
   &=& 
   \big(
      pl_{\text{lettuce},\, \text{\#42},\, 48}, \; 
      we_{\text{lettuce},\, \text{\#42},\, [48,50]}, \;
      we_{\text{lettuce},\, \text{\#42},\, [51,53]}, \;
      we_{\text{lettuce},\, \text{\#42},\, [54,56]}, 
   \\ && \hspace{5.4cm}
      gr_{\text{lettuce},\, \text{\#42},\, [48,56]}, \;
      ha_{\text{lettuce},\, \text{\#42},\, [48,56]} \;
      \big), \\
   &\dots& \\
   \chi_{56} 
   &=& 
   \big(
      pl_{\text{lettuce},\, \text{\#42},\, 56}, \; 
      we_{\text{lettuce},\, \text{\#42},\, [56,58]}, \;
      we_{\text{lettuce},\, \text{\#42},\, [59,61]}, \;
      we_{\text{lettuce},\, \text{\#42},\, [62,64]}, 
   \\ && \hspace{5.4cm}
      gr_{\text{lettuce},\, \text{\#42},\, [56,64]}, \;
      ha_{\text{lettuce},\, \text{\#42},\, [56,64]} \;
      \big)
\end{eqnarray*}
that express that if a head of lettuce is planted between the third week of November (week 47)
and the last week of January (week 56), up to eight weeks can pass before it must be
harvested; in exchange for that, we must weed three times. 


\subsection{Objective function}

The objective function we want to  maximize is thus
\[
   f 
   \ = \
   \sum_{c\in C, y\in Y} y_{c,w} \sum_{a\in A} x_{c,w,a}
\]


\section{Allocation}


\section{Implementing and optimizing the problem formulation}

\subsection{Implementation}

We will probably use either PHP or Python to generate the input file to the optimizer from
a database of constraints and other data.

\subsection{Optimizations}
As remarked in \cite{artigues-etal11}, there is no need to create
events for the ending of the last activities. 

\section{Server-side technology}

Gilad's intention is to make the program available on a server. That's
fine, except that we need to be able to install c++ and cbc on such a server.

\bibliographystyle{siam}
\bibliography{specification}

\end{document}
